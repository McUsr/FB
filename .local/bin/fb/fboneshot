#!/bin/bash
# OneShot. 
# OneShot Take an adhoc backup of a folder - a snapshot.  2022 (c) Mcusr -- Vim license.
#
# The backup is stored in a parallell structure to the Periodic folder structure.
# This is a reworked version of the "DailySnapshot.sh" script.

# This script gets executed every time the timer interval specified in this
# case DailySnapshot.timer fires and is made for  being  started by the ../governor.sh 
# the name of the script should give an idea as to what you are backing up.

# You need to edit it to align with the folder you share with Linux for backup
# purposes, and with the folder you want to make an hourly backup of.  you also
# need to install notify-send.
# https://www.reddit.com/r/Crostini/comments/zl5nte/sending_notifications_to_chromeos_desktop_from/
#
# 27/12: Added "sparsity" doesn't make unneccessary backups anymore. 
# 12/01: Real deal ready for production, for what DailySnapshot backups are concerned. 

# exec 4>&2 2> >(while read -r REPLY; do printf >&4 '<3>%s\n' "$REPLY"; done)
# exec 2>&1 >/dev/null
# trap 'exec >&2-' EXIT
# Above only works for services!
# https://serverfault.com/questions/573946/how-can-i-send-a-message-to-the-systemd-journal-from-the-command-line

#########
#  sudo ls | tee /dev/tty | sed -n '/[a-z][A-Z]*/ s:^:<3>:p' | systemd-cat -t testing
########  

err_report() {
	echo "${0##*/} : Error on line $1"
	echo "${0##*/} : Please report this issue at 'https://github.com/McUsr/FB/issues'" 
}

trap 'err_report $LINENO' ERR
VERSION="\"v0.0.2\""

LOG_TO_JOURNAL=false

DRYRUN=1
# controls whether we are going to print the backup command to the console/journal,
# (when DRYRUN=0) or if were actually going to perform.
DEBUG=1
# 
# prints out debug messages to the console/journal if its on when instigated by
# systemd --user.
TO_CONSOLE=0
# controls whether debug output will be sent to the journal when the script is called 
# from the terminal, and output be sent to the journal anyway, when the script is run
# implicitly by a daemon.
ARCHIVE_OUTPUT=1

if [ -r ~/.local/bin/fb/shared_functions.sh ] ; then 
	source ~/.local/bin/fb/shared_functions.sh
else
	echo -e  "Can't source: ~/.local/bin/fb/shared_functions.sh\nTerminates... " >&2
	exit 255
fi 

if [ x"$FB" = x ] ; then 
	 	echo -e "${0##*/}" "The variable \$FB isn't set, is the system initialized? You need configure it.\nTerminating..." | journalThis 2 OneShot
		exit 255
fi
# checks if we can get online so we have a guarranteed connection to our google drive
consoleHasInternet

consoleFBFolderIsMounted

PNAME=${0##*/}
GETOPT_COMPATIBLE=true

if [ $# -eq 0 ] ; then 
	echo -e $PNAME : "Too few arguments. At least I need a path to a directory, I should make a backup of.\nExecute \"$PNAME -h\" for help. Terminating..." | journalThis 2 OneShot
 exit 2
fi

help() {
cat  << EOF

$PNAME:  Backups the folder specified into the folder backup system OneShot root-directory,
         under the path name of the folder, and yet another folder specifying time and date,
         for coherent access across the folder backup system.

syntax:

  $PNAME [options] <source folder> [ -o <destination> ]

  Options:
  
  -h | --help.    Shows this help.
  -n | --dry-run  Shows what would have happened
  -v | --verbose  Shows more detailed output.
  -V | --version  Shows the version of $PNAME ($VERSION).
  -c | --create-exclude-file Lets you use $EDITOR to edit a file with globs to exclude.
  
EOF
}
# https://stackoverflow.com/questions/402377/using-getopts-to-process-long-and-short-command-line-options
TEMP=$(getopt -o chnvV --longoptions create-exclude-file,help,dry-run,verbose,version \
              -n "$PNAME" -- "$@")

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 2 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"
DRYRUN=false
VERBOSE=false
CREATE_EXCLUDE_FILE=false

# echo NARG1 : $#

PARSE_DEBUG=1
while true; do
	if [ $PARSE_DEBUG -eq 0 ] ; then 
	echo "while ...." 
		case "$1" in
			-h | --help ) echo 'h' ; help ; exit 0 ;;
			-n | --dry-run ) echo '--dry-run' ; DRYRUN=true; shift ;;
			-v | --verbose ) echo 'verbose ' ; VERBOSE=true; shift ;;
			-V | --version ) echo 'version' ;echo $PNAME : $VERSION ; exit 0 ;;
			-c | --create-exclude-file ) echo 'create exclude file' ; CREATE_EXCLUDE_FILE=true; shift ;;
			-- ) shift; break ;;
	#    * ) break ;;
		esac
	else 
		case "$1" in
			-h | --help )  help ; exit 0 ;;
			-n | --dry-run ) DRYRUN=true; shift ;;
			-v | --verbose ) VERBOSE=true; shift ;;
			-V | --version ) echo $PNAME : $VERSION ; exit 0 ;;
			-c | --create-exclude-file ) echo 'create exclude file' ; CREATE_EXCLUDE_FILE=true; shift ;;
			-- ) shift; break ;;
	#    * ) break ;;
		esac
	fi
done

if [ $PARSE_DEBUG -eq 0 ] ; then 
	echo "$@"
	echo 'Ended while '
	echo NARG2 : $#
	echo D1 : $1
fi

# We need to collect the options we should pass along.

if [ $# -ne 1 ] ; then 
		echo -e "$PNAME: I didn't get a mandatory parameter. A source-folder to back up.\n\"$PNAME -h\" for help.\nTerminating..."	| journalThis 2 OneShot
		exit 2
fi
BACKUP_OPTIONS=

if [ $DRYRUN = true ] ; then 
	BACKUP_OPTIONS+="--dry-run"
fi
if [ $VERBOSE = true ] ; then 
	BACKUP_OPTIONS+=" --verbose"
fi
# --create-exclude-file isn't an option, it's more of a command.


TARGET_FOLDER=$(realpath "$1")

if [[ $DEBUG -eq 0  || $VERBOSE = true ]] ; then 
	echo "$PNAME : TARGET_FOLDER: $TARGET_FOLDER" | journalThis 7 OneShot
fi

if [ ! -d $TARGET_FOLDER ] ; then 
	echo "$PNAME : $TARGET_FOLDER isn't a directory. Terminating..." | journalThis 2 OneShot
  exit 1
fi

# next up, is to construct the full-symlink  name

SYMLINK_NAME=$(echo $TARGET_FOLDER | sed -ne 's:^/::' -e 's:/:-:g' -e 's:^\.:\\.:' -e 's:[-]\(\.\):-\\\1:' -e 'p')
# TODO: a candidate for a function.

if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
	echo "$PNAME : SYMLINK_NAME: $SYMLINK_NAME." | journalThis 7 OneShot
fi

BACKUP_CONTAINER=$FB/OneShot/$SYMLINK_NAME
if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
	echo "$PNAME : Backups of $TARGET_FOLDER are stored in: $BACKUP_CONTAINER" | journalThis 7 OneShot
fi

# can be called from the OneShot routine.
# or we can somehow had our own idea of how to start 
# the things up, so we just silently create it.
# we are here to solve problems, not create them.

if [ ! -d "$BACKUP_CONTAINER" ] ; then
	# selv om det er DRYRUN s√• beholder vi denne!
	mkdir -p "$BACKUP_CONTAINER" 
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
		echo -e "$PNAME : BACKUP_CONTAINER: $BACKUP_CONTAINER didn\'t exist.\nMaking $BACKUP_CONTAINER." | journalThis 7 OneShot
	fi
else
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
		echo "$PNAME : BACKUP_CONTAINER: $BACKUP_CONTAINER DID  exist." | journalThis 7 OneShot
	fi
fi	

# we generate todays folder name. which is todays 'daily' backup folder.
TODAYS_BACKUP_FOLDER=$BACKUP_CONTAINER/$(baseNameDateStamped $SYMLINK_NAME)
CREATED_TODAYS_BACKUP_FOLDER=1
if [ ! -d "$TODAYS_BACKUP_FOLDER" ] ; then 
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
		echo "$PNAME : TODAYS_BACKUP_FOLDER: \$TODAYS_BACKUP_FOLDER didn't exist. Creating it:\nmkdir -p i"$TODAYS_BACKUP_FOLDER"." | journalThis 7 OneShot
	fi
	if [ $DRYRUN = false ] ; then 
		CREATED_TODAYS_BACKUP_FOLDER=0
		mkdir -p "$TODAYS_BACKUP_FOLDER" 
	else
		echo "$PNAME : Todays backup folder didn't exist, creating it:\n mkdir -p $TODAYS_BACKUP_FOLDER"
	fi
else 
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
		echo  "$PNAME : TODAYS_BACKUP_FOLDER: $TODAYS_BACKUP_FOLDER DID exist." | journalThis 7 OneShot
	fi
fi

# Time to figure out which script we are going to use: an making any preparations:

if [ $CREATE_EXCLUDE_FILE = true ] ; then 
	# is the editor variable set?
	if [[ ! -v EDITOR || ! -x "$EDITOR" ]] ; then  
		echo -e  "$PNAME : The variable \$EDITOR wasn't set or didn't point to a binary.\nYou need to set assign the \$EDITOR variable in .bashrc or .bash_profile, then  \"exec bash\" and try again.\nTerminating..." | journalThis 5 OneShot
		exit 2
	fi
	# Only one place a the exclude file. And if it doesn't exist, then we'll make it.
	if [ ! -d ~/.local/bin/fb/OneShot/"$SYMLINK_NAME".d ] ; then 
		if [[ $DEBUG -eq 0 || $DRYRUN = true ]] ; then 
			echo -e "$PNAME : The folder \"~/.local/bin/fb/OneShot/$SYMLINK_NAME.d\" didn't exist.\nMaking it.\nmkdir -p ~/.local/bin/fb/OneShot/$SYMLINK_NAME.d" | journalThis 7 OneShot
		fi
		mkdir -p ~/.local/bin/fb/OneShot/"$SYMLINK_NAME".d
		touch ~/.local/bin/fb/OneShot/"$SYMLINK_NAME".d/exclude.file
	fi

	$EDITOR ~/.local/bin/fb/OneShot/"$SYMLINK_NAME".d/exclude.file
	if [ $? - ne 0 ] ; then 
		echo -e "$PNAME : Something went wrong during editing.\n
		~/.local/bin/fb/OneShot/$SYMLINK_NAME.d/exclude.file\nTerminating..." | journalThis 2 OneShot
		exit 255
	fi
fi
# Exclude file out of the way, time to figure out if there are any "dropin" scripts that should be used.



# FIND THE CORRECT SCRIPT/DROPIN-SCRIPT TO EXECUTE IF ANY:
# it is time to figure out which restore script we are going to use.
# So, the standard restore script for restoring a OneShot backup is in the
# ~/.local/bin/fb/OneShot and the standard-name should be OneShot.restore.sh 
# it should exist, and it should be executable.
# TODO:  transfer this part back to governor.sh and fboneshot.sh

if [ ! -x ~/.local/bin/fb/OneShot/OneShot.backup.sh ] ; then
	# same if with DRYRUN or VERBOSE
	echo -e $PNAME : "I can't find the backup script  ~/.local/bin/fb/OneShot/OneShot.backup.sh\nThis is a critical error.\nTerminates..." | journalThis 2 OneShot
	exit 255
else
	BACKUP_SCRIPT=~/.local/bin/fb/OneShot/OneShot.backup.sh
	if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : "Current backup script is : $BACKUP_SCRIPT" | journalThis 7 OneShot
	fi
fi
GENERAL_DROPIN=1
# the place to look for a general replacement is in the OneShot.d folder.
if [  -f ~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh ] ; then
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
		echo $PNAME : " I have a readable backup script:  ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh" | journalThis 7 OneShot
	fi
	if [ ! -x ~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh ] ; then
		echo -e $PNAME : " I found a backup dropin script: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh.\nBut it isn't executabe.\nTerminates.." | journalThis 7 OneShot
		exit 5
	else
		GENERAL_DROPIN=0
		BACKUP_SCRIPT=~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh
		if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo $PNAME : "I found a general backup dropin script: Current backup script is : $BACKUP_SCRIPT" | journalThis 7 OneShot
		fi
	fi
elif [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : "I didn't find  a general backup dropin script at: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh." | journalThis 7 OneShot 
fi
LOCAL_DROPIN=1
# the place to look for a general replacement is in the OneShot.d folder.
if [  -f ~/.local/bin/fb/OneShot/$SYMLINK_NAME.d/OneShot.backup.sh ] ; then
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
		echo $PNAME : "I have a readable local dropin backup script: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh" | journalThis 7 OneShot
	fi
	if [ ! -x ~/.local/bin/fb/OneShot/$SYMLINK_NAME.d/OneShot.backup.sh ] ; then
		echo -e $PNAME : " I found a local backup dropin script: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.backup.sh.\nBut it isn't executabe.\nTerminates.." | journalThis 7 OneShot
		exit 5
	else
		LOCAL_DROPIN=0
		BACKUP_SCRIPT=~/.local/bin/fb/OneShot/$SYMLINK_NAME.d/OneShot.backup.sh
		if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo $PNAME : "I found a local backup dropin script : Current backup script is : $BACKUP_SCRIPT" | journalThis 7 OneShot
		fi
	fi
elif [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : "I didn't find  a local backup dropin script at: ~/.local/bin/fb/OneShot/$SYMLINK_NAME.d" | journalThis 7 OneShot
fi

if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
# TODO: Needs to look at fbrestore here:
	echo $PNAME : executing $BACKUP_SCRIPT $BACKUP_OPTIONS  $TARGET_FOLDER  $TODAYS_BACKUP_FOLDER | journalThis 7 OneShot
fi


EXIT_CODE=0
# TODO: trenger en interrupt handler her?
# Installerer den her, setter exitcode til 130, og rydder opp hvis ble trappet
trap '' ERR
$BACKUP_SCRIPT $BACKUP_OPTIONS  $TARGET_FOLDER  $TODAYS_BACKUP_FOLDER $SYMLINK_NAME
EXIT_CODE=$?
if [[ $EXIT_CODE -gt 1 && $CREATED_TODAYS_BACKUP_FOLDER -eq 0 ]] ; then 
	if [ $DRYRUN = false ] ; then 
		if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo "$PNAME : Removing todays backup folder due to fatal errors:\n rm -fr $TODAYS_BACKUP_FOLDER"
		fi
		rm -fr $TODAYS_BACKUP_FOLDER 
	else
		echo "$PNAME : Removing todays backup folder due to fatal errors:\n rm -fr $TODAYS_BACKUP_FOLDER"
	fi 
fi

# TODO: CLEANUP AFTER DRYRUN, OR ERRORS. fbrestore too.
# BACKUP container folder, m√• fjernes!
