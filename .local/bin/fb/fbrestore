#!/bin/bash

err_report() {
	echo "${0##*/} :Error on line $1"
	echo "${0##*/} : Please report this issue at 'https://github.com/McUsr/FB/issues'" 
}

trap 'err_report $LINENO' ERR
VERSION="\"v0.0.2\""

if [ -r ~/.local/bin/fb/shared_functions.sh ] ; then 
	source ~/.local/bin/fb/shared_functions.sh
else
	echo -e  "Can't source: ~/.local/bin/fb/shared_functions.sh\nTerminates... " >&2
	exit 255
fi 

if [ x"$FB" = x ] ; then 
	 	echo "${0##*/}" "The variable \$FB isn't set, is the system initialized? You need configure it.\nTerminating..." >& 2
		exit 255
fi

# We need to check if we have an internet connection 
consoleHasInternet

# We need to check if the drive is mounted accordingly to $FB
consoleFBFolderIsMounted

PNAME=${0##*/}
GETOPT_COMPATIBLE=true

if [ $# -eq 0 ] ; then 
	echo -e $PNAME : "Too few arguments. At least I need a backup source to restore from.\nExecute \"$PNAME -h\" for help. Terminating..." >&2
 exit 2
fi

DEBUG=1
help() {
cat  << EOF

$PNAME:  Restores a previous folder backup, made with the fb system.

syntax:

  $PNAME [options] <source folder> [ -o <destination> ]

  Options:
  
  -h| --help.    Shows this help.
  -o| --dest-dir [folder-name] Folder-name mandatory when --dest-dir given.
  -n| --dry-run  Shows what would have happened
  -v| --verbose  Shows more detailed output.
  -F| --force    Force a restore to take place into a folder you don't own.
  -V| --version  Shows the version of $PNAME ($VERSION).
  
EOF
}
# set -x
# https://stackoverflow.com/questions/402377/using-getopts-to-process-long-and-short-command-line-options
TEMP=$(getopt -o hno:vFV --longoptions help,dest-dir:,verbose,dry-run,force,version \
              -n "$PNAME" -- "$@")

if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 2 ; fi

# Note the quotes around '$TEMP': they are essential!
eval set -- "$TEMP"

DRYRUN=false
VERBOSE=false
FORCE=false
DST_FOLDER_SET=false

PARSE_DEBUG=1
while true; do
	if [ $PARSE_DEBUG -eq 0 ] ; then 
	echo "while ...."
		case "$1" in
			-h | --help ) echo 'h' ; help ; exit 0 ;;
			-n | --dry-run ) echo '--dry-run' ; DRYRUN=true; shift ;;
			-v | --verbose ) echo 'verbose ' ; VERBOSE=true; shift ;;
			-o | --dest-dir ) echo 'dest-dir' ; DST_FOLDER_SET=true; DEST_FOLDER="$2"; shift 2 ;;
			-F | --force ) echo 'FORCE' ; FORCE=true ; shift ;;
			-V | --version ) echo 'version' ;echo $PNAME : $VERSION ; exit 0 ;;
			-- ) shift; break ;;
	#    * ) break ;;
		esac
	else 
		case "$1" in
			-h | --help )  help ; exit 0 ;;
			-n | --dry-run ) DRYRUN=true; shift ;;
			-v | --verbose ) VERBOSE=true; shift ;;
			-o | --dest-dir ) DST_FOLDER_SET=true; DEST_FOLDER="$2"; shift 2 ;;
			-F | --force ) FORCE=true ; shift ;;
			-V | --version ) echo $PNAME : $VERSION ; exit 0 ;;
			-- ) shift; break ;;
	#    * ) break ;;
		esac
	fi
done

if [ $PARSE_DEBUG -eq 0 ] ; then 
	echo "$@"
	echo 'Ended while '
	echo NARG2 : $#
	echo D1 : $1
fi

# Needs to check if variables that holds files starts with one or two dashes.
# separates between longopts and shortopts for simplicity.

if [ $DST_FOLDER_SET = false ] ; then 
	if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : DEST_FOLDER NOT SET 
	elif [ $DRYRUN = true ] ; then
		echo "$PNAME : Destination folder not set, making one under /tmp."
	fi
else
#  echo "testing folder name $DEST_FOLDER" 
	# Vet it against All the options.
	for opt in h o d v D F V ; do 
	 if [[ $DEST_FOLDER = $opt  || $DEST_FOLDER = "-"$opt ]] ; then 
		 echo -e $PNAME : "The destination folder has an invalid name ($DEST_FOLDER).\n Did you forget to specify one?\nExecute \"$PNAME -h\" for help. Terminating..." >&2
		 exit 2
	 fi
	done 

	for opt in help dest-dir verbose dry-run force version ; do 
	 if [[ $DEST_FOLDER = $opt  || $DEST_FOLDER = "--"$opt ]] ; then 
		 echo -e $PNAME : "The destination folder has an invalid name ($DEST_FOLDER).\n Did you forget to specify one?\nExecute \"$PNAME -h\" for help. Terminating..." >&2
		 exit 2
	 fi
 done
fi

PARSE_DEBUG=1
if [ $PARSE_DEBUG -eq 0 ] ; then 
	echo DRYRUN : $DRYRUN
	echo VERBOSE : $VERBOSE
	echo DST_FOLDER_SET : $DST_FOLDER_SET  : DST_FOLDER : $DEST_FOLDER
	echo FORCE : $FORCE
fi

RESTORE_OPTIONS=

if [ $DRYRUN = true ] ; then 
	RESTORE_OPTIONS+="--dry-run"
fi
if [ $VERBOSE = true ] ; then 
	RESTORE_OPTIONS+=" --verbose"
fi
if [ $FORCE = true ] ; then 
	RESTORE_OPTIONS+=" --force"
fi

if [ $# -ne 1 ] ; then 
	# leniency, if we forgot the -o switch, and arg 2 exists as a folder, and we haven't set a destination, then we will silently let it slide through.
	if [[ $# -eq 2 && $DST_FOLDER_SET = false && -d "$2" ]] ; then 
		:
	else
		echo -e $PNAME : "Wrong number of   arguments. I need one argument for a backup source.\nExecute \"$PNAME -h\" for help. Terminating..." >&2
		exit 1
	fi
fi


# Check out if our source file or folder exists. 
if [ ! -r "$1" ] ; then
	echo -e $PNAME : "I can\'t seem to find the file or folder  \"$1\".\nTerminating..." >&2
	exit 1
else
	BACKUP_SOURCE_REALPATH=$(realpath $1)
	if [ $PARSE_DEBUG -eq 0 ] ; then 
		echo -e "Found \"$1\"\n (\"$BACKUP_SOURCE_REALPATH\")" >&2
	fi
fi 

KIND=$(backupKind "$1")

# DEBUG_VAR for periodic here.

if [ "$KIND" = "OneShot" ] ; then 
	if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : "Current backup KIND is One Shot Backup."	
	fi
	FULL_SYMLINK_NAME=$(identifyBackupSourceFolder "OneShot" "$BACKUP_SOURCE_REALPATH" )
  # still need this one for figuring if we are restoring to the
	# original folder, which we won't without the --force flag.
	PATH_TO_SOURCE_FOR_BACKUP=$(pathFromFullSymlinkName "$FULL_SYMLINK_NAME" )
	# Question is: Do I need anything more than this?
	# Though, I must indeed veryify that there is a timestamped folder after.
	TIME_STAMPED_BACKUP_CONTAINING_FOLDER=$(identifyTimeStampedBackupContainingFolder "$KIND/$FULL_SYMLINK_NAME" "$BACKUP_SOURCE_REALPATH")
	EXIT_STATUS=$?
	# Apparaently, it isn't that easy to exit directly, when you're in a subshell
	if [ $EXIT_STATUS -ne 0 ] ; then 
		trap '' ERR
	 	exit $EXIT_STATUS
	fi 
	if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
		echo $PNAME : "Time stamped backup container: $TIME_STAMPED_BACKUP_CONTAINING_FOLDER"
	fi
elif [ "$KIND" = "Periodic" ] ; then 
	PERIODIC_BACKUP_SCHEME=$(periodicBackupScheme $BACKUP_SOURCE_REALPATH )
	if [[ $VERBOSE = true || $DEBUG -eq 0  ]] ;then 
		echo $PNAME : PERIODIC_BACKUP_SCHEME : ">"$PERIODIC_BACKUP_SCHEME"<"
		echo $PNAME : "Periodic backups NOT IMPLEMENTED YET:"
		exit 5
	fi
else 
	# bail out if finding a different kind.
	# We may do something about this in the futurem, or some kind of translation for names and stuff
	# for the French! in the Future....far Future...
	echo -e $PNAME "WRONG BACKUP KIND DISCOVERED\nWe only handle backups of the \"OneShot\" or \"Periodic\" kind, not \"$KIND\".\nTerminating..."
 exit 2	
fi

# DETERMINE THE BACKUP-DESTINATION
MADE_FOLDER=false
if [ $DST_FOLDER_SET = false ] ; then 
	# We will make a folder under /tmp
	DEST_FOLDER=/tmp/$FULL_SYMLINK_NAME/$TIME_STAMPED_BACKUP_CONTAINING_FOLDER
	if [ $DRYRUN = false ] ; then 
		if [ -d "$DEST_FOLDER" ] ; then 
			rm -fr /tmp/"$FULL_SYMLINK_NAME"/"$TIME_STAMPED_BACKUP_CONTAINING_FOLDER"
			if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
				echo -e "$PNAME : "$DEST_FOLDER" existed\nDeleting it and it's contents."
			fi
		fi
		MADE_FOLDER=true
		mkdir -p "$DEST_FOLDER" 
	else
		if [ -d "$DEST_FOLDER" ] ; then 
			echo -e "$PNAME : Destination folder existed, maybe with contents.\n executing: rm -fr /tmp/"$FULL_SYMLINK_NAME"/"$TIME_STAMPED_BACKUP_CONTAINING_FOLDER"." 
		fi
		echo -e "$PNAME : Recreating destination folder,\n executing:  mkdir -p $DEST_FOLDER" 
	fi

else
	# There is set  a destination folder on the command line.
	if [ "$DEST_FOLDER" = "$PATH_TO_SOURCE_FOR_BACKUP" ] ; then  

		if [ $FORCE = false ] ; then 
		
			# DRYRUN not considered here, since the result is the same.

			echo -e $PNAME : "You want to to restore the backup into the original folder.\nYou need to apply the '--force' option on the command line to achieve that.\nTerminating..."
			exit 2
		fi
	else
		# no protection from doing stupid things as to restore/dump a backup into the $HOME folder
		if [ $DRYRUN = false  ] ; then 
			if [ ! -d "$DEST_FOLDER" ] ; then 
				if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
					echo $PNAME : mkdir -p "$DEST_FOLDER" 
				fi
				MADE_FOLDER=true
				mkdir -p "$DEST_FOLDER"
			else 
				if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then 
					echo "$PNAME : Dest folder for restore: "$DEST_FOLDER" existed. -No unlinking of it before the restore!"  
				fi
			fi
		else
			echo $PNAME : mkdir -p "$DEST_FOLDER" 
		fi
	fi
fi
 

# FIND THE CORRECT SCRIPT/DROPIN-SCRIPT TO EXECUTE IF ANY:
if [ "$KIND" = "OneShot" ] ; then 
# it is time to figure out which restore script we are going to use.
# So, the standard restore script for restoring a OneShot backup is in the
# ~/.local/bin/fb/OneShot and the standard-name should be OneShot.restore.sh 
# it should exist, and it should be executable.
# TODO:  transfer this part back to governor.sh and fboneshot.sh

	if [ ! -x ~/.local/bin/fb/OneShot/OneShot.restore.sh ] ; then
		# same if with DRYRUN or VERBOSE
		echo $PNAME : "I can't find the restore script  ~/.local/bin/fb/OneShot/OneShot.restore.sh\nThis is a critical error.\nTerminates..."
		exit 255
	else
		RESTORE_SCRIPT=~/.local/bin/fb/OneShot/OneShot.restore.sh
		if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo $PNAME : "Current restore script is : $RESTORE_SCRIPT"
		fi
	fi
	GENERAL_DROPIN=1
	# the place to look for a general replacement is in the OneShot.d folder.
	if [  -f ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh ] ; then
		if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
			echo $PNAME : " I have a readable ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh"
		fi
		if [ ! -x ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh ] ; then
			echo $PNAME : " I found a dropin.sh: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh.\nBut it isn't executabe.\nTerminates.."
			exit 5
		else
			GENERAL_DROPIN=0
			RESTORE_SCRIPT=~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh
			if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
				echo $PNAME : "I found a general dropin.sh : Current restore script is : $RESTORE_SCRIPT"
			fi
		fi
	elif [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo $PNAME : "I didn't find  a general dropin.sh at: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh."
	fi
	LOCAL_DROPIN=1
	# the place to look for a general replacement is in the OneShot.d folder.
	if [  -f ~/.local/bin/fb/OneShot/$FULL_SYMLINK_NAME.d/OneShot.restore.sh ] ; then
		if [[ $DEBUG -eq 0 || $VERBOSE = true ]] ; then
			echo $PNAME : "I have a readable ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh"
		fi
		if [ ! -x ~/.local/bin/fb/OneShot/$FULL_SYMLINK_NAME.d/OneShot.restore.sh ] ; then
			echo $PNAME : " I found a dropin.sh: ~/.local/bin/fb/OneShot/OneShot.d/OneShot.restore.sh.\nBut it isn't executabe.\nTerminates.."
			exit 5
		else
			LOCAL_DROPIN=0
			RESTORE_SCRIPT=~/.local/bin/fb/OneShot/$FULL_SYMLINK_NAME.d/OneShot.restore.sh
			if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
				echo $PNAME : "I found a local dropin.sh : Current restore script is : $RESTORE_SCRIPT"
			fi
		fi
	elif [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo $PNAME : "I didn't find  a local dropin.sh at: ~/.local/bin/fb/OneShot/$FULL_SYMLINK_NAME.d"
	fi
fi

restore_exit_code=0
if [ $DRYRUN = true ] ; then 
	echo $PNAME :  $RESTORE_SCRIPT "$RESTORE_OPTIONS" "$BACKUP_SOURCE_REALPATH" "$DEST_FOLDER"
else
	if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
		echo $PNAME : $RESTORE_SCRIPT "$RESTORE_OPTIONS" "$BACKUP_SOURCE_REALPATH" "$DEST_FOLDER"
	fi
	$RESTORE_SCRIPT $RESTORE_OPTIONS "$BACKUP_SOURCE_REALPATH" "$DEST_FOLDER"
	restore_exit_code=$?
fi

# We do the cleanup in OneShot.restore.sh 
if [ $restore_exit_code -ge 2 ] ; then 

	if [ $restore_exit_code -eq 130 ] ; then 
			echo "$PNAME : User interrupted the operation"
	else
			echo "$PNAME : A fatal error occurred."
	fi
	if [[ $MADE_FOLDER = true && -d "$DEST_FOLDER" ]] ; then 
			rm -fr "$DEST_FOLDER"
		if [[ $VERBOSE = true || $DEBUG -eq 0 ]] ; then 
			echo "$PNAME : rm -fr "$DEST_FOLDER"."
		fi
	fi

fi
exit $restore_exit_code


